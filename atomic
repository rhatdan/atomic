#!/usr/bin/python -Es
# Copyright (C) 2014-2015 Red Hat
# AUTHOR: Dan Walsh <dwalsh@redhat.com>
# see file 'COPYING' for use and warranty information
#
# atomic is a tool for managing Atomic Systems and Containers
#
#    This program is free software; you can redistribute it and/or
#    modify it under the terms of the GNU General Public License as
#    published by the Free Software Foundation; either version 2 of
#    the License, or (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
#    02110-1301 USA.
#
#
import os
import sys
import gettext
import argparse
import subprocess

import docker
import Atomic
from Atomic import diff
from Atomic import images
from Atomic import scan
from Atomic import top
from Atomic import mount
from Atomic import verify
from Atomic import storage
from Atomic import host
from Atomic import info
from Atomic import install
from Atomic import help as Help
from Atomic import run
from Atomic import ps
from Atomic.util import write_err, NoDockerDaemon, add_opt
import traceback
from Atomic.mount import MountError

PROGNAME = "atomic"
gettext.bindtextdomain(PROGNAME, "/usr/share/locale")
gettext.textdomain(PROGNAME)
try:
    # pylint: disable=unexpected-keyword-arg
    gettext.install(PROGNAME, unicode=True, codeset='utf-8')
except TypeError:
    # Failover to python3 install
    gettext.install(PROGNAME, codeset='utf-8')
except IOError:
    import builtins # pylint: disable=import-error
    builtins.__dict__['_'] = str

class HelpByDefaultArgumentParser(argparse.ArgumentParser):

    def error(self, message):
        write_err('%s: %s' % (self.prog, message))
        write_err("Try '%s --help' for more information." % self.prog)
        sys.exit(2)

    def print_usage(self, message="too few arguments"):
        self.prog = " ".join(sys.argv)
        self.error(message)

# Code for python2 copied from Adrian Sampson hack
# https://gist.github.com/sampsyo/471779
#
class AliasedSubParsersAction(argparse._SubParsersAction): # pylint: disable=protected-access
    class _AliasedPseudoAction(argparse.Action): # pylint: disable=abstract-method
        def __init__(self, name, aliases, help_text):
            dest = name
            if aliases:
                dest += ' (%s)' % ','.join(aliases)
            sup = super(AliasedSubParsersAction._AliasedPseudoAction, self) #pylint: disable=protected-access
            sup.__init__(option_strings=[], dest=dest, help=help_text)

    def add_parser(self, name, **kwargs):
        if 'aliases' in kwargs:
            aliases = kwargs['aliases']
            del kwargs['aliases']
        else:
            aliases = []

        parser = super(AliasedSubParsersAction, self).add_parser(name, **kwargs)

        # Make the aliases work.
        for alias in aliases:
            self._name_parser_map[alias] = parser
        # Make the help text reflect them, first removing old help entry.
        if 'help' in kwargs:
            help = kwargs.pop('help') # pylint: disable=redefined-builtin
            self._choices_actions.pop()
            pseudo_action = self._AliasedPseudoAction(name, aliases, help)
            self._choices_actions.append(pseudo_action)

        return parser

def need_root():
    sub_function = sys.argv[1] if sys.argv[1] not in ['--debug'] else sys.argv[2]
    exit("Some operations for '%s' require root access." % sub_function)
    sys.exit(1)

def create_parser(help_text):
    parser = HelpByDefaultArgumentParser(description=help_text)
    parser.register('action', 'parsers', AliasedSubParsersAction)
    parser.add_argument('-v', '--version', action='version', version=Atomic.__version__)
    parser.add_argument('--debug', default=False, action='store_true')
    subparser = parser.add_subparsers(help=_("commands"))

    # atomic cluster (if commctl.cli is available)
    try:
        import commctl.cli
        clusterp = subparser.add_parser(
            "cluster", help=_("execute cluster management commands"))
        commctl.cli.add_cluster_commands(clusterp)
    except ImportError:
        pass

    diff.cli(subparser)
    Help.cli(subparser)

    if os.path.exists("/usr/bin/rpm-ostree") and os.path.exists("/run/ostree-booted"):
        host.cli(subparser)
    info.cli(subparser)

    install.cli(subparser)
    images.cli(subparser)
    mount.cli(subparser)
    ps.cli(subparser)

    # atomic push
    pushp = subparser.add_parser(
        "push", aliases=['upload'], help=_("push latest image to repository"),
        epilog="push the latest specified image to a repository.")
    pushp.set_defaults(func='push')

    # atomic pull
    pullp = subparser.add_parser("pull", help=_("pull latest image from a repository"),
        epilog="pull the latest specified image from a repository.")
    pullp.add_argument("--storage", dest="backend", help=_("Specify the storage."))
    pullp.add_argument("image", help=_("image id"))
    pullp.set_defaults(func='pull_image')

    # making it so we cannot call both the --pulp and --satellite commands
    # at the same time (mutually exclusive)
    pushgroup = pushp.add_mutually_exclusive_group()
    pushgroup.add_argument("--pulp",
                           default=False,
                           action="store_true",
                           help=_("push image using pulp"))
    pushgroup.add_argument("--satellite",
                           default=False,
                           action="store_true",
                           help=_("push image using Satellite"))

    pushp.add_argument("--verify_ssl",
                         default=None,
                         action="store_true",
                         help=_("flag to verify ssl of registry"))
    pushp.add_argument("--debug",
                         default=None,
                         action="store_true",
                         help=_("debug mode"))
    pushp.add_argument("-U", "--url",
                         dest="url",
                         default=None,
                         help=_("URL for remote registry"))
    pushp.add_argument("-u", "--username",
                         default=None,
                         dest="username",
                         help=_("Username for remote registry"))
    pushp.add_argument("-p", "--password",
                         default=None,
                         dest="password",
                         help=_("Password for remote registry"))
    pushp.add_argument("image", help=_("container image"))
    pushp.add_argument("-a", "--activation_key",
                         default=None,
                         dest="activation_key",
                         help=_("Activation Key"))
    pushp.add_argument("-r", "--repository_id",
                         default=None,
                         dest="repo_id",
                         help=_("Repository ID"))
    # pushp.add_argument("--activation_key_name",
    #                      default=None,
    #                      dest="activation_key_name",
    #                      help=_("Activation Key Name"))
    # pushp.add_argument("--repo_name", "--repository_name",
    #                      default=None,
    #                      dest="repo_name",
    #                      help=_("Repository Name"))
    # pushp.add_argument("--org_name", "--organization_name",
    #                      default=None,
    #                      dest="org_name",
    #                      help=_("Organization Name"))

    run.cli(subparser, atomic)
    scan.cli(subparser)

    # atomic stop
    stopp = subparser.add_parser(
        "stop", help=_("execute container image stop method"),
        epilog="atomic will just stop the container if it is running, if "
        "image does not specify LABEL STOP")
    stopp.set_defaults(func='stop')
    add_opt(stopp)
    stopp.add_argument("-n", "--name", dest="name", default=None,
                       help=_("name of container"))
    stopp.add_argument("image", help=_("container image"))
    stopp.add_argument("args", nargs=argparse.REMAINDER,
                          help=_("Additional arguments appended to the image "
                                 "stop method"))

    storage.cli(subparser)
    top.cli(subparser)
    # atomic rhost (if commctl.cli is available)
    try:
        import commctl.cli
        rhostp = subparser.add_parser(
            "rhost", help=_("execute cluster host management commands"))
        commctl.cli.add_host_commands(rhostp)
    except ImportError:
        pass

    # atomic uninstall
    uninstallp = subparser.add_parser(
        "uninstall", help=_("execute container image uninstall method"),
        epilog="atomic uninstall attempts to read the LABEL UNINSTALL "
        "field in the image, if it does not exist atomic will "
        "remove the image from your machine.  You could add a "
        "LABEL UNINSTALL command to your Dockerfile like: 'LABEL "
        "UNINSTALL %s'" % atomic.print_uninstall())
    uninstallp.set_defaults(func='uninstall')
    add_opt(uninstallp)
    uninstallp.add_argument("-n", "--name", dest="name", default=None,
                            help=_("name of container"))
    uninstallp.add_argument("-f", "--force", default=False, dest="force",
                            action="store_true",
                            help=_("remove all containers based on this "
                                   "image"))
    uninstallp.add_argument("image", help=_("container image"))
    uninstallp.add_argument("args", nargs=argparse.REMAINDER,
                            help=_("Additional arguments appended to the "
                                   "image uninstall method"))
    mount.cli_unmount(subparser)
    # atomic update
    updatep = subparser.add_parser(
        "update", help=_("pull latest container image from repository"),
        epilog="atomic update downloads the latest container image. If a "
        "previously created  container based on this image exists, "
        "the container will continue to use the old image.  Use "
        "--force to remove the outdated container.")
    updatep.set_defaults(func='update')
    updatep.add_argument("-f", "--force", default=False, dest="force",
                         action="store_true",
                         help=_("remove all containers based on this image"))
    if Atomic.syscontainers.OSTREE_PRESENT:
        updatep.add_argument("--set", dest="setvalues",
                             action='append',
                             help=_("Specify a variable in the VARIABLE=VALUE "
                                    "form for a system container"))
    updatep.add_argument("--container", dest="container",
                         action='store_true', default=False,
                         help=_('update an installed container'))
    updatep.add_argument("image", help=_("container image"))

    verify.cli(subparser)

    # atomic version
    versionp = subparser.add_parser(
        "version", help=_("display image 'Name Version Release' label"),
        epilog="atomic version displays the image version information, if "
        "it is provided")
    versionp.add_argument("-r", "--recurse", default=False, dest="recurse",
                          action="store_true",
                          help=_("recurse through all layers"))
    versionp.set_defaults(func='print_version')
    versionp.add_argument("image", help=_("container image"))

    return parser

if __name__ == '__main__':
    try:
        with Atomic.Atomic() as atomic:
            aparser = create_parser(atomic.help())
            args = aparser.parse_args()
            _class = atomic if '_class' not in args else args._class() # pylint: disable=protected-access
            _class.set_args(args)
            _func = getattr(_class, args.func)
            sys.exit(_func())
    except KeyboardInterrupt:
        sys.exit(0)
    except (ValueError, IOError, docker.errors.DockerException, NoDockerDaemon) as e:
        write_err("%s" % str(e))
        if os.geteuid() != 0:
            need_root()
        sys.exit(1)
    except subprocess.CalledProcessError as e:
        write_err("")
        sys.exit(e.returncode)
    except AttributeError:
        # python3 throws exception on no args to atomic
        aparser.print_usage()
        sys.exit(1)
    except MountError as e:
        if str(e).find("Permission denied") > 0:
            need_root()
        else:
            write_err("%s" % str(e))
        sys.exit(1)
    except Exception as e: # pylint: disable=broad-except
        write_err("%s" % str(e))
        sys.exit(1)
    except SystemExit as e:
        # Overriding debug args to avoid a traceback from sys.exit()
        if 'args' in locals():
            args.debug = False
        sys.exit(e.code)
    finally:
        if 'args' in locals() and args.debug:
            traceback.print_exc(file=sys.stdout)
